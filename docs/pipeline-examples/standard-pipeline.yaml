# Standard Pipeline Example
# GitLab CI / Jenkins style - stages and jobs
# Organized workflow with parallel job execution within stages

name: "Standard Multi-Stage Pipeline"
description: "Standard pipeline with stages and jobs organization"
type: standard

# Repository information
repo: https://github.com/user/enterprise-app.git
branch: main

# Define stages in execution order
stages: ["prepare", "build", "test", "security", "deploy", "verify"]

# Jobs mapped to stages
jobs:
  # Prepare stage
  setup:
    stage: prepare
    script: |
      echo "Setting up build environment..."
      rustup update stable
      cargo --version
      
  dependencies:
    stage: prepare
    script: |
      echo "Caching dependencies..."
      cargo fetch
      
  # Build stage
  compile:
    stage: build
    script: |
      echo "Compiling application..."
      cargo build --release
      ls -la target/release/
      
  documentation:
    stage: build
    script: |
      echo "Generating documentation..."
      cargo doc --no-deps
      
  # Test stage - multiple jobs run in parallel
  unit_tests:
    stage: test
    script: |
      echo "Running unit tests..."
      cargo test --lib
      
  integration_tests:
    stage: test
    script: |
      echo "Running integration tests..."
      cargo test --test integration
      
  benchmark_tests:
    stage: test
    script: |
      echo "Running benchmark tests..."
      cargo bench --no-run
      
  # Security stage
  audit:
    stage: security
    script: |
      echo "Running security audit..."
      cargo audit
      
  vulnerability_scan:
    stage: security
    script: |
      echo "Scanning for vulnerabilities..."
      if command -v trivy >/dev/null 2>&1; then
        trivy fs .
      else
        echo "Trivy not available, skipping scan"
      fi
      
  # Deploy stage
  build_image:
    stage: deploy
    script: |
      echo "Building Docker image..."
      docker build -t enterprise-app:${BUILD_VERSION} .
      docker tag enterprise-app:${BUILD_VERSION} enterprise-app:latest
      
  push_image:
    stage: deploy
    script: |
      echo "Pushing to registry..."
      docker push enterprise-app:${BUILD_VERSION}
      docker push enterprise-app:latest
      
  deploy_staging:
    stage: deploy
    script: |
      echo "Deploying to staging..."
      kubectl set image deployment/enterprise-app app=enterprise-app:${BUILD_VERSION} -n staging
      kubectl rollout status deployment/enterprise-app -n staging
      
  # Verify stage
  smoke_tests:
    stage: verify
    script: |
      echo "Running smoke tests..."
      sleep 30  # Wait for deployment
      curl -f https://staging.example.com/health
      curl -f https://staging.example.com/api/status
      
  performance_tests:
    stage: verify
    script: |
      echo "Running performance tests..."
      if command -v k6 >/dev/null 2>&1; then
        k6 run performance-test.js
      else
        echo "k6 not available, skipping performance tests"
      fi

# Triggers
triggers:
  - trigger_type: manual
    config: {}
  - trigger_type: git_push
    config:
      repository: "user/enterprise-app"
      branch_patterns: ["main", "release/*"]
  - trigger_type: schedule
    config:
      cron_expression: "0 2 * * *"  # Daily at 2 AM

# Environment variables
environment:
  RUST_BACKTRACE: "1"
  CARGO_TERM_COLOR: "always"
  BUILD_VERSION: "${GITHUB_SHA:-v1.0.0}"
  DOCKER_REGISTRY: "registry.enterprise.com"
  KUBECONFIG: "/etc/kubernetes/config"
  STAGING_URL: "https://staging.example.com"

# Global settings
timeout: 3600  # 1 hour
retry_count: 1

# Notifications
notifications:
  on_success:
    - target_type: slack
      config:
        slack_channel: "#deployments"
        slack_token: "${SLACK_TOKEN}"
    - target_type: email
      config:
        email: "devops@enterprise.com"
  on_failure:
    - target_type: slack
      config:
        slack_channel: "#alerts"
        slack_token: "${SLACK_TOKEN}"
    - target_type: webhook
      config:
        webhook_url: "https://monitoring.enterprise.com/webhook/pipeline-failure"
  on_start:
    - target_type: github
      config:
        github_status: true