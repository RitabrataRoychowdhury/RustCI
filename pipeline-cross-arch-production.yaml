name: "Cross-Architecture RustCI Deployment (Production)"
description: "Deploy RustCI from ARM Mac to AMD64 VPS with production-ready configuration"
version: "1.0"

# Production-ready environment variables (using 'variables' field for RustCI compatibility)
variables:
  # Production mode configuration
  TESTING_MODE: "false"

  # Cross-architecture build configuration
  BUILD_PLATFORM: "linux/amd64"
  BUILDER_NAME: "multiarch-builder"

  # VPS Configuration - Use environment variables for security
  VPS_IP: "${VPS_IP}"
  VPS_USERNAME: "${VPS_USERNAME}"
  VPS_PASSWORD: "${VPS_PASSWORD}"

  # Application secrets - Use environment variables for security
  MONGODB_URI: "${MONGODB_URI}"
  MONGODB_DATABASE: "${MONGODB_DATABASE}"
  JWT_SECRET: "${JWT_SECRET}"
  JWT_EXPIRED_IN: "${JWT_EXPIRED_IN}"
  JWT_SIGNUP_EXPIRED_IN: "${JWT_SIGNUP_EXPIRED_IN}"
  JWT_REFRESH_EXPIRED_IN: "${JWT_REFRESH_EXPIRED_IN}"
  GITHUB_OAUTH_CLIENT_ID: "${GITHUB_OAUTH_CLIENT_ID}"
  GITHUB_OAUTH_CLIENT_SECRET: "${GITHUB_OAUTH_CLIENT_SECRET}"
  GITHUB_OAUTH_REDIRECT_URL: "${GITHUB_OAUTH_REDIRECT_URL}"
  CLIENT_ORIGIN: "${CLIENT_ORIGIN}"
  PORT: "${PORT:-8000}"
  RUST_ENV: "${RUST_ENV:-production}"
  RUST_LOG: "${RUST_LOG:-info}"
  ENABLE_METRICS: "${ENABLE_METRICS:-true}"

triggers:
  - trigger_type: manual
    config: {}
  - trigger_type: webhook
    config:
      path: "/deploy/production"

stages:
  - name: "prepare"
    description: "Validate environment and setup cross-architecture build system"
    steps:
      - name: "validate-production-mode"
        step_type: shell
        config:
          command: |
            echo "ğŸ” Validating production mode configuration..."
            if [ "${TESTING_MODE}" = "false" ]; then
              echo "âœ… Production mode enabled"
              echo "ğŸ”’ Using environment variables for secrets"
            else
              echo "âš ï¸  WARNING: Testing mode is enabled in production pipeline"
              echo "âš ï¸  Set TESTING_MODE=false for production deployment"
            fi
        timeout: 30
        retry_count: 1
        on_failure: "fail"

      - name: "validate-required-secrets"
        step_type: shell
        config:
          command: |
            echo "ğŸ” Validating required secrets..."
            MISSING_SECRETS=""

            [ -z "${VPS_PASSWORD}" ] && MISSING_SECRETS="${MISSING_SECRETS} VPS_PASSWORD"
            [ -z "${MONGODB_URI}" ] && MISSING_SECRETS="${MISSING_SECRETS} MONGODB_URI"
            [ -z "${JWT_SECRET}" ] && MISSING_SECRETS="${MISSING_SECRETS} JWT_SECRET"
            [ -z "${GITHUB_OAUTH_CLIENT_SECRET}" ] && MISSING_SECRETS="${MISSING_SECRETS} GITHUB_OAUTH_CLIENT_SECRET"

            if [ -n "${MISSING_SECRETS}" ]; then
              echo "âŒ Missing required secrets:${MISSING_SECRETS}"
              echo "ğŸ’¡ Ensure all environment variables are set before running this pipeline"
              exit 1
            fi

            echo "âœ… All required secrets are present"
        timeout: 30
        retry_count: 1
        on_failure: "fail"

      - name: "setup-docker-buildx"
        step_type: shell
        config:
          command: |
            echo "ğŸ”§ Setting up Docker buildx for cross-architecture builds..."

            # Check if builder already exists
            if docker buildx ls | grep -q "${BUILDER_NAME}"; then
              echo "ğŸ“‹ Builder '${BUILDER_NAME}' already exists, using existing builder"
              docker buildx use "${BUILDER_NAME}"
            else
              echo "ğŸ†• Creating new multi-platform builder: ${BUILDER_NAME}"
              docker buildx create --name "${BUILDER_NAME}" --use
            fi

            # Bootstrap the builder
            echo "ğŸš€ Bootstrapping builder..."
            docker buildx inspect --bootstrap

            # Verify platform support
            echo "ğŸ” Verifying platform support..."
            docker buildx ls | grep "${BUILDER_NAME}"

            echo "âœ… Docker buildx setup completed"
        timeout: 300
        retry_count: 2
        on_failure: "fail"

      - name: "validate-vps-connection"
        step_type: shell
        config:
          command: |
            echo "ğŸ” Testing VPS connection..."
            sshpass -p "${VPS_PASSWORD}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 "${VPS_USERNAME}@${VPS_IP}" "echo 'VPS connection successful'"
            echo "âœ… VPS connection validated"
        timeout: 60
        retry_count: 3
        on_failure: "fail"

  - name: "build-image"
    description: "Build AMD64-compatible Docker image using buildx"
    steps:
      - name: "validate-workspace"
        step_type: shell
        config:
          command: |
            echo "ğŸ” Validating workspace for build..."

            if [ ! -f Dockerfile ]; then
              echo "âŒ Dockerfile not found in workspace"
              exit 1
            fi

            if [ ! -f Cargo.toml ]; then
              echo "âŒ Cargo.toml not found in workspace"
              exit 1
            fi

            echo "ğŸ“‹ Workspace contents:"
            ls -la

            echo "âœ… Workspace validation passed"
        timeout: 30
        retry_count: 1
        on_failure: "fail"

      - name: "build-cross-arch-image"
        step_type: shell
        config:
          command: |
            echo "ğŸ”¨ Building AMD64 Docker image on ARM Mac..."

            # Build for AMD64 platform
            docker buildx build \
              --platform "${BUILD_PLATFORM}" \
              --load \
              -t rustci:local-amd64 \
              -f Dockerfile \
              .

            # Tag for production deployment
            docker tag rustci:local-amd64 rustci:production

            echo "âœ… Cross-architecture build completed"
            docker images | grep rustci
        timeout: 1800 # 30 minutes
        retry_count: 2
        on_failure: "fail"

      - name: "validate-image-architecture"
        step_type: shell
        config:
          command: |
            echo "ğŸ” Validating image architecture..."

            # Check image architecture
            ARCH_INFO=$(docker image inspect --format='{{.Architecture}}/{{.Os}}' rustci:local-amd64)
            echo "ğŸ“‹ Image architecture: ${ARCH_INFO}"

            if [ "${ARCH_INFO}" != "amd64/linux" ]; then
              echo "âŒ Expected amd64/linux, got ${ARCH_INFO}"
              exit 1
            fi

            echo "âœ… Architecture validation passed: ${ARCH_INFO}"
        timeout: 60
        retry_count: 1
        on_failure: "fail"

      - name: "test-local-container"
        step_type: shell
        config:
          command: |
            echo "ğŸ§ª Testing container startup locally..."

            # Start test container
            docker run --rm -d --name rustci-arch-test -p 8001:8000 \
              -e RUST_LOG=debug \
              -e MONGODB_URI="${MONGODB_URI}" \
              -e JWT_SECRET="${JWT_SECRET}" \
              rustci:local-amd64

            # Wait for startup
            sleep 15

            # Verify container is running
            if docker ps | grep rustci-arch-test; then
              echo "âœ… Container started successfully"
              
              # Test architecture inside container
              CONTAINER_ARCH=$(docker exec rustci-arch-test uname -m)
              echo "ğŸ“‹ Container architecture: ${CONTAINER_ARCH}"
              
              if [ "${CONTAINER_ARCH}" = "x86_64" ]; then
                echo "âœ… Container architecture validation passed"
              else
                echo "âŒ Expected x86_64, got ${CONTAINER_ARCH}"
                docker stop rustci-arch-test
                exit 1
              fi
              
              # Test health endpoints (optional - may not be ready)
              if curl -f http://localhost:8001/health 2>/dev/null; then
                echo "âœ… Health endpoint responding"
              else
                echo "âš ï¸  Health endpoint not responding (may be normal during startup)"
              fi
              
              # Stop test container
              docker stop rustci-arch-test
              echo "âœ… Local container test completed"
            else
              echo "âŒ Container failed to start"
              docker logs rustci-arch-test 2>/dev/null || true
              exit 1
            fi
        timeout: 180
        retry_count: 2
        on_failure: "fail"

  - name: "transfer-and-deploy"
    description: "Transfer image to VPS and deploy with rollback support"
    steps:
      - name: "backup-current-deployment"
        step_type: shell
        config:
          command: |
            echo "ğŸ’¾ Creating backup of current deployment..."
            sshpass -p "${VPS_PASSWORD}" ssh -o StrictHostKeyChecking=no "${VPS_USERNAME}@${VPS_IP}" '
              if docker ps | grep rustci-production; then
                BACKUP_TAG="rustci:previous-$(date +%Y%m%d-%H%M%S)"
                docker commit rustci-production "${BACKUP_TAG}"
                docker tag rustci-production rustci:previous
                echo "âœ… Backup created: ${BACKUP_TAG}"
              else
                echo "ğŸ“‹ No current deployment to backup"
              fi
            '
        timeout: 120
        retry_count: 2
        on_failure: "continue"

      - name: "transfer-image-compressed"
        step_type: shell
        config:
          command: |
            echo "ğŸ“¦ Transferring Docker image to VPS with compression..."

            # Transfer with compression and progress indication
            docker save rustci:production | gzip | \
            sshpass -p "${VPS_PASSWORD}" ssh -C -o StrictHostKeyChecking=no -o ServerAliveInterval=60 \
              "${VPS_USERNAME}@${VPS_IP}" "gunzip | docker load"

            echo "âœ… Image transfer completed"

            # Verify image on VPS
            sshpass -p "${VPS_PASSWORD}" ssh -o StrictHostKeyChecking=no "${VPS_USERNAME}@${VPS_IP}" \
              "docker images | grep rustci:production"
        timeout: 600 # 10 minutes
        retry_count: 3
        on_failure: "fail"

      - name: "stop-existing-container"
        step_type: shell
        config:
          command: |
            echo "ğŸ›‘ Stopping existing RustCI container..."
            sshpass -p "${VPS_PASSWORD}" ssh -o StrictHostKeyChecking=no "${VPS_USERNAME}@${VPS_IP}" '
              docker stop rustci-production 2>/dev/null || true
              docker rm rustci-production 2>/dev/null || true
              echo "âœ… Existing container stopped and removed"
            '
        timeout: 60
        retry_count: 2
        on_failure: "continue"

      - name: "deploy-new-container"
        step_type: shell
        config:
          command: |
            echo "ğŸš€ Deploying new RustCI container..."
            sshpass -p "${VPS_PASSWORD}" ssh -o StrictHostKeyChecking=no "${VPS_USERNAME}@${VPS_IP}" "
              docker run -d \
                --name rustci-production \
                -p 8080:8000 \
                -e MONGODB_URI='${MONGODB_URI}' \
                -e MONGODB_DATABASE='${MONGODB_DATABASE}' \
                -e JWT_SECRET='${JWT_SECRET}' \
                -e JWT_EXPIRED_IN='${JWT_EXPIRED_IN}' \
                -e JWT_SIGNUP_EXPIRED_IN='${JWT_SIGNUP_EXPIRED_IN}' \
                -e JWT_REFRESH_EXPIRED_IN='${JWT_REFRESH_EXPIRED_IN}' \
                -e GITHUB_OAUTH_CLIENT_ID='${GITHUB_OAUTH_CLIENT_ID}' \
                -e GITHUB_OAUTH_CLIENT_SECRET='${GITHUB_OAUTH_CLIENT_SECRET}' \
                -e GITHUB_OAUTH_REDIRECT_URL='${GITHUB_OAUTH_REDIRECT_URL}' \
                -e CLIENT_ORIGIN='${CLIENT_ORIGIN}' \
                -e PORT=${PORT} \
                -e RUST_ENV=${RUST_ENV} \
                -e RUST_LOG=${RUST_LOG} \
                -e ENABLE_METRICS=${ENABLE_METRICS} \
                -v /var/run/docker.sock:/var/run/docker.sock \
                --restart unless-stopped \
                rustci:production
              
              echo 'âœ… RustCI deployment completed'
            "
        timeout: 300 # 5 minutes
        retry_count: 2
        on_failure: "fail"

  - name: "smoke-test"
    description: "Verify deployment health with comprehensive checks"
    steps:
      - name: "wait-for-startup"
        step_type: shell
        config:
          command: |
            echo "â³ Waiting for RustCI to start up..."
            sleep 30
            echo "âœ… Initial startup wait completed"
        timeout: 60
        retry_count: 1
        on_failure: "continue"

      - name: "health-check-primary-endpoint"
        step_type: shell
        config:
          command: |
            echo "ğŸ¥ Testing primary health endpoint..."

            MAX_ATTEMPTS=10
            ATTEMPT=1

            while [ ${ATTEMPT} -le ${MAX_ATTEMPTS} ]; do
              echo "Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: Testing /api/healthchecker..."
              
              if curl -f -s --connect-timeout 10 --max-time 10 "http://${VPS_IP}:8080/api/healthchecker" >/dev/null 2>&1; then
                echo "âœ… Primary health endpoint (/api/healthchecker) responding"
                exit 0
              fi
              
              echo "â³ Health endpoint not ready, waiting 10 seconds..."
              sleep 10
              ATTEMPT=$((ATTEMPT + 1))
            done

            echo "âŒ Primary health endpoint failed after ${MAX_ATTEMPTS} attempts"
            exit 1
        timeout: 120 # 2 minutes
        retry_count: 3
        on_failure: "fail"

      - name: "health-check-fallback-endpoint"
        step_type: shell
        config:
          command: |
            echo "ğŸ¥ Testing fallback health endpoint..."

            if curl -f -s --connect-timeout 10 --max-time 10 "http://${VPS_IP}:8080/health" >/dev/null 2>&1; then
              echo "âœ… Fallback health endpoint (/health) responding"
            else
              echo "âš ï¸  Fallback health endpoint not responding (primary passed, this is acceptable)"
            fi
        timeout: 30
        retry_count: 1
        on_failure: "continue"

      - name: "verify-container-status"
        step_type: shell
        config:
          command: |
            echo "ğŸ“Š Verifying container status on VPS..."
            sshpass -p "${VPS_PASSWORD}" ssh -o StrictHostKeyChecking=no "${VPS_USERNAME}@${VPS_IP}" '
              if docker ps | grep rustci-production; then
                echo "âœ… RustCI container is running"
                echo "ğŸ“‹ Container details:"
                docker ps | grep rustci-production
                echo "ğŸ“‹ Recent logs:"
                docker logs --tail 10 rustci-production
              else
                echo "âŒ RustCI container not found or not running"
                echo "ğŸ“‹ All containers:"
                docker ps -a | grep rustci || echo "No rustci containers found"
                exit 1
              fi
            '
        timeout: 60
        retry_count: 1
        on_failure: "fail"

  - name: "cleanup"
    description: "Clean up resources and provide deployment summary"
    steps:
      - name: "cleanup-local-images"
        step_type: shell
        config:
          command: |
            echo "ğŸ§¹ Cleaning up local Docker images..."

            # Remove dangling images
            docker image prune -f

            # Keep the production image but remove intermediate build images
            echo "ğŸ“‹ Remaining rustci images:"
            docker images | grep rustci || echo "No rustci images found"

            echo "âœ… Local cleanup completed"
        timeout: 60
        retry_count: 1
        on_failure: "continue"

      - name: "deployment-summary"
        step_type: shell
        config:
          command: |
            echo "ğŸ‰ Cross-architecture production deployment completed successfully!"
            echo ""
            echo "ğŸ“‹ Deployment Summary:"
            echo "  â€¢ Source Architecture: $(uname -m) ($(uname -s))"
            echo "  â€¢ Target Architecture: AMD64 (Linux)"
            echo "  â€¢ VPS IP: ${VPS_IP}"
            echo "  â€¢ Application Port: 8080"
            echo "  â€¢ Environment: Production"
            echo ""
            echo "ğŸ”— Access URLs:"
            echo "  â€¢ Main Application: http://${VPS_IP}:8080"
            echo "  â€¢ Health Check: http://${VPS_IP}:8080/api/healthchecker"
            echo "  â€¢ Fallback Health: http://${VPS_IP}:8080/health"
            echo ""
            echo "ğŸ”§ Verification Commands:"
            echo "  â€¢ Test health: curl -f http://${VPS_IP}:8080/api/healthchecker"
            echo "  â€¢ Check container: ssh ${VPS_USERNAME}@${VPS_IP} 'docker ps | grep rustci-production'"
            echo "  â€¢ View logs: ssh ${VPS_USERNAME}@${VPS_IP} 'docker logs rustci-production'"
            echo ""
            echo "ğŸ”’ Security Status:"
            echo "  â€¢ Production mode: Enabled"
            echo "  â€¢ Environment variables: Used for all secrets"
            echo "  â€¢ Hardcoded secrets: None"
        timeout: 30
        retry_count: 1
        on_failure: "continue"

# Rollback configuration for deployment failures
rollback:
  enabled: true
  trigger_conditions:
    - health_check_failures: 3
    - deployment_timeout: true
  steps:
    - name: "rollback-to-previous"
      step_type: shell
      config:
        command: |
          echo "ğŸ”„ Rolling back to previous deployment..."
          sshpass -p "${VPS_PASSWORD}" ssh -o StrictHostKeyChecking=no "${VPS_USERNAME}@${VPS_IP}" '
            # Check if previous image exists
            if docker images | grep "rustci:previous"; then
              echo "ğŸ“‹ Found previous image, rolling back..."
              
              # Stop current container
              docker stop rustci-production 2>/dev/null || true
              docker rm rustci-production 2>/dev/null || true
              
              # Start previous version
              docker run -d \
                --name rustci-production \
                -p 8080:8000 \
                --restart unless-stopped \
                rustci:previous
              
              echo "âœ… Rollback completed successfully"
              
              # Verify rollback
              sleep 10
              if docker ps | grep rustci-production; then
                echo "âœ… Rollback container is running"
              else
                echo "âŒ Rollback container failed to start"
                exit 1
              fi
            else
              echo "âŒ No previous image found for rollback"
              echo "ğŸ“‹ Available images:"
              docker images | grep rustci || echo "No rustci images found"
              exit 1
            fi
          '
      timeout: 180
      retry_count: 1
      on_failure: "fail"

# Global pipeline configuration
timeout: 3600 # 1 hour total timeout
retry_count: 1
on_failure: "rollback"
